
 class RFGFairyManeger extends RFGObjectManager{    
    var fairy;
    var x,y;            //妖精の初期出現位置
    var width,height;    //ウィンドウのサイズ
    var maxFairy = 20;
    var rand;
    var wnd;
  
    
    function RFGFairyManeger(wnd, lay, owner) {
		super.RFGObjectManager(wnd, lay, owner);

        rand = new Math.RandomGenerator();
        
        
        this.timer.enabled = true;
    }

    //一定時間ごとに妖精を出現させる
    function action(ev) {
		if (this.maxFairy <= this.objects.count) return; //生成上限数の処理
		
		popPosition();
        var obj = new RFGFairy(this.window, this.parentLayer, this);
        obj.layer.setPos(x, y);//レイヤーの座標だけかえてもFairyオブジェクトの座標は変わらない
		obj.x = x;//妖精の座標変更
		obj.y = y;//妖精の座標変更
		obj.layer.visible = true;
		obj.setVectForCenter(1.25);//中央方向へ向かうようにする
		obj.enable = 1;
		this.objects.add(obj);
    }
    
    //妖精のポップ位置を定める
    function popPosition(){
        var way = rand.random32() % 4;//0:上　1:右　2:下　3:左
        switch(way){
        case 0:
            x=(int)(rand.random() * this.parentLayer.width);
            y=0;
            break;
        case 1:
            x=width - 10;
            y=(int)(rand.random() * this.parentLayer.height);
            break;
        case 2:
            x=(int)(rand.random() * this.parentLayer.width);
            y=height - 10;
            break;
        case 3:
            x=0;
            y=(int)(rand.random() * this.parentLayer.height);
            break;
        }
    }
    
	function consult(obj) {
		//相談を上位オブジェクトにたらいまわし
		return this.owner.consult(obj);
	}
    
    function finalize(){
        for(var i=0; i<this.maxFairy;i++){
            invalidate this.fairy[i];
        }
    }
}

