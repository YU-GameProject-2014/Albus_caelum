/**
 * 衝突判定レイヤー(矩形)
 * @author gewalt01
 */
class  RFGCollisionLayer extends RFGBasicLayer
{
	var owner; //管理者 //双方向参照やめるかもしれない
	var areas = new Array(); //衝突判定領域配列[x, y, width, height]
	var enable; //有効かどうか
	
	/**
	 * コンストラクタ
	 * @param	wnd   ウインドウオブジェクト
	 * @param	lay   親レイヤ
	 * @param	owner 管理者
	 */
	function RFGCollisionLayer(wnd, lay, owner) {
		super.RFGBasicLayer(wnd, lay);
		this.owner = owner;
		this.visible = false;
		this.enable = false;
        this.hitThreshold = 256;
	}
	
	/**
	 * 衝突判定領域追加
	 * @param	x
	 * @param	y
	 * @param	width
	 * @param	height
	 */
	function addArea(x, y, width, height)
	{
		var area = % [];
		area["x"]      = x;
		area["y"]      = y;
		area["width"]  = width;
		area["height"] = height;
		this.areas.add(area);
		
		this.drawArea();
	}
	
	/**
	 * 衝突判定 //まだできてないよ
	 * @param	collay 判定対象となるRFGCollisionLayerオブジェクト
	 */
	function isCollision(collay) {
		if (this.enable === false) return;
		
        for(var i = 0; i < this.areas.count; i++)
        {
            for(var j = 0; j < collay.areas.count; j++)
            {
                 
                //サイズが不正な領域の処理はしない
                if(this.areas[i]["width"] <= 0 || this.areas[i]["height"]  <= 0 || collay.areas[j]["width"]  <= 0 || this.areas[j]["height"]  <= 0) continue;
            
                
                var pos = new Array();
                pos.add(%[]);
                pos.add(%[]);
                
                //レイヤーからはみ出してる部分を無視
                pos[0]["left"]   = 0 < this.areas[i]["x"] ?  this.boundingLeft + this.areas[i]["x"] : this.boundingLeft;
                pos[0]["right"]  = this.areas[i]["x"] + this.areas[i]["width"] < this.width ? this.boundingLeft + this.areas[i]["x"] + this.areas[i]["width"] : this.boundingLeft + this.width;
                pos[0]["top"]    = 0 < this.areas[i]["y"] ?  this.boundingTop + this.areas[i]["y"] : this.boundingTop;
                pos[0]["bottom"] = this.areas[i]["y"] + this.areas[i]["height"] < this.height ? this.boundingTop + this.areas[i]["y"] + this.areas[i]["height"] : this.boundingTop + this.height;

                pos[1]["left"]   = 0 < collay.areas[j]["x"] ?  collay.boundingLeft + collay.areas[j]["x"] : collay.boundingLeft;
                pos[1]["right"]  = collay.areas[j]["x"] + collay.areas[j]["width"] < collay.width ? collay.boundingLeft + collay.areas[j]["x"] + collay.areas[j]["width"] : collay.boundingLeft + collay.width;
                pos[1]["top"]    = 0 < collay.areas[j]["y"] ?  collay.boundingTop + collay.areas[j]["y"] : collay.boundingTop;
                pos[1]["bottom"] = collay.areas[j]["y"] + collay.areas[j]["height"] < collay.height ? collay.boundingTop + collay.areas[j]["y"] + collay.areas[j]["height"] : collay.boundingTop + collay.height;

                //衝突判定
                if( (pos[0]["left"] < pos[1]["right"] ) &&
                    (pos[1]["left"] < pos[0]["right"] ) &&
                    (pos[0]["top"]  < pos[1]["bottom"]) &&
                    (pos[1]["top"]  < pos[0]["bottom"]) ) {

                    return true;
                }
            }
        }
	}
	
	/**
	 * 衝突領域の描画
	 */
	function drawArea() {
		this.colorRect(0, 0, this.width, this.height, 0x000000, -255);
		
		for (var i = 0; i < this.areas.count; i++ )
		{
			this.fillRect(this.areas[i]["x"], 
			              this.areas[i]["y"], 
			              this.areas[i]["width"], 
						  this.areas[i]["height"], 
						  0x7F00FF00);
		}
	}
}