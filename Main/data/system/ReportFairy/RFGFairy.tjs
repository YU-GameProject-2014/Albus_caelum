/**
 * 妖精本体となるクラス
 * @author gewalt01
 */
class RFGFairy extends RFGObject{
    var x, y;     //座標
    var vx, vy;   //速度ベクトル
    var enable;   //生死
	var fairyLifebar; //RFGLifebar
	var hp = 5;//デフォルト値5
	var actionPattern; //RFGFairyActionPattern
	var sound;

    
	/**
	 * コンストラクタ, レイヤー作成とタイマーの設定
	 * @param	wnd   描画するウインドウオブジェクト
	 * @param	lay   親となるレイヤー
	 * @param	owner 妖精オブジェクトの管理者
	 */
    function RFGFairy(wnd, lay, owner) {
		super.RFGObject(wnd, lay, owner);
		/*
		 * これらはデフォルト設定です
		 */
		
		//this.setImageLayer(RFGFairyLayerCreator.createFactLayer(wnd, this.layer, this));
		//this.setCollisionLayer(RFGLayerCreator.createFairyCollisionLayer(wnd, this.layer, this));
		//this.setLifebar(this.hp);
		this.actionPattern = new RFGFairyActionPattern(this);
		
        this.setVect(0, 0);
		//this.sound = new WaveSoundBuffer(null);
        this.enable=0;
        this.timer.interval = 1000/60;
        this.timer.enabled = true;
    }
    
	/**
	 * マウスヒット時の処理, 初期状態では妖精へのダメージ処理
	 */
    function onMouseEnter() {
		this.hp--;//とりあえず実装, 将来的にはHPオブジェクトに分離予定
		this.fairyLifebar.life = this.hp;

		if (this.hp <= 0) {
			this.onKilled();
		} else {
			//this.sound.open("sound/004.wav");
			//this.sound.play();
		}
    }
    
	/**
	 * 妖精オブジェクトの移動
	 * @param	dx x方向移動量
	 * @param	dy y方向移動量
	 */
    function move(dx, dy){
        this.x += dx;
        this.y += dy;
        this.layer.setPos(this.x, this.y);
    }

	function onNoLife() {
		
	}
	
	/**
	 * 妖精が死んでしまった時の処理
	 */
	function onKilled() {
		//現在はあたり判定無効化して半透明にする処理を
        this.layer.opacity = 128;
        this.layer.hitThreshold = 256;
		
		//ダメージを与えられなくする
		this.atack = function() { return false; };
		
		//衝突判定無効化
		this.collisionLayer.enable = false;
		
		this.actionPattern.onKilled();
	}
	
    /**
     * タイマーイベント
     * @param	ev イベントパラメータ
     */
    function action(ev){
        if (this.enable === false) return;

		this.actionPattern.action();
    }

    /**
     * 管理者オブジェクトに自身の状況を報告, 操作を管理者にゆだねる
     */
    function advice() {
        return this.owner.consult(this);
    }

	/**
	 * 速度ベクトル設定
	 * @param	vx x方向速度
	 * @param	vy y方向速度
	 */
    function setVect(vx, vy){
        this.vx = vx;
        this.vy = vy;
    }

	/**
	 * 中心方向へ向かうようベクトルを設定
	 * @param	d 速度
	 */
    function setVectForCenter(d){
        var parent_center_pos_x = this.layer.parent.width / 2;
        var parent_center_pos_y = this.layer.parent.height / 2;
        var r = Math.sqrt(Math.pow(parent_center_pos_x - this.x, 2) + Math.pow(parent_center_pos_y - this.y, 2));
        var dx = d * (parent_center_pos_x - this.x) / r;
        var dy = d * (parent_center_pos_y - this.y) / r;
        this.setVect(dx, dy);
    }
	
	function atack(obj) {
	    return true;	
	}

	/**
	 * 衝突判定レイヤー設定
	 * @param	layer 衝突判定レイヤー
	 */
	function setCollisionLayer(layer) {
		this.collisionLayer = layer;
		this.collisionLayer.visible = true;
	}
	
	/**
	 * 妖精の画像設定
	 * @param	layer 画像レイヤ
	 */
	function setImageLayer(layer) {
        this.imageLayer = layer;
		this.imageLayer.visible = true;
		
		this.layer.width = this.imageLayer.width;
		this.layer.height = this.imageLayer.height;
	}

	function setLifebar(hp) {
		this.hp = hp;
		this.fairyLifebar = RFGLifebarCreator.createFairyLifebar(this.window, this.layer, this);
		this.fairyLifebar.maxlife = this.fairyLifebar.life = this.hp;
	}

	/**
	 * finalize
	 */
    function finalize(){
        super.finalize();
        invalidate this.layer;
		invalidate this.actionPattern;
    }
}
