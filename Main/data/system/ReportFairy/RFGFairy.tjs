/**
 * 妖精本体となるクラス
 * @author gewalt01
 */
class RFGFairy extends RFGObject{
    var x, y;     //座標
    var vx, vy;   //速度ベクトル
    var enable;   //生死
    var layer;      //RFGFairyLayer
	var hp = 5;//とりあえず実装, 将来的にはHPオブジェクトに分離予定
    
	/**
	 * コンストラクタ, レイヤー作成とタイマーの設定
	 * @param	wnd   描画するウインドウオブジェクト
	 * @param	lay   親となるレイヤー
	 * @param	owner 妖精オブジェクトの管理者
	 */
    function RFGFairy(wnd, lay, owner) {
		super.RFGObject(wnd, lay, owner);
        //this.layer.parentがNULLになる可能性あり
        this.layer = RFGLayerCreator.createFairyLayer(wnd, lay, this);
        this.setVect(0, 0);
        this.enable=0;
        this.timer.interval = 1000/60;
        this.timer.enabled = true;
    }
    
	/**
	 * マウスヒット時の処理, 初期状態では妖精へのダメージ処理
	 */
    function onMouseEnter() {
		this.hp--;//とりあえず実装, 将来的にはHPオブジェクトに分離予定
		if(this.hp <= 0) this.onKilled();
    }
    
	/**
	 * 妖精オブジェクトの移動
	 * @param	dx x方向移動量
	 * @param	dy y方向移動量
	 */
    function move(dx, dy){
        this.x += dx;
        this.y += dy;
        this.layer.setPos(this.x, this.y);
        
        //画面からはみ出たら消滅
        if (this.layer.left + this.layer.width < 0 || this.layer.top  + this.layer.height < 0 ||
            this.layer.parent.width  < this.layer.left|| this.layer.parent.height < this.layer.top
        ){
            this.suicide();
			return;
        }
        
		//移動後の処理を親に相談
        if (this.advice()) {
            this.suicide();
			return;
        }
    }

	/**
	 * 妖精が死んでしまった時の処理
	 */
	function onKilled() {
		//現在はあたり判定無効化して半透明にする処理を
        this.layer.opacity = 128;
        this.layer.hitThreshold = 256;
	}
	
    /**
     * タイマーイベント
     * @param	ev イベントパラメータ
     */
    function action(ev){
        if(this.enable) this.move(vx, vy);
    }

    /**
     * 管理者オブジェクトに自身の状況を報告, 操作を管理者にゆだねる
     */
    function advice() {
        return this.owner.consult(this);
    }

	/**
	 * 速度ベクトル設定
	 * @param	vx x方向速度
	 * @param	vy y方向速度
	 */
    function setVect(vx, vy){
        this.vx = vx;
        this.vy = vy;
    }

	/**
	 * 中心方向へ向かうようベクトルを設定
	 * @param	d 速度
	 */
    function setVectForCenter(d){
        var parent_center_pos_x = this.layer.parent.width / 2;
        var parent_center_pos_y = this.layer.parent.height / 2;
        var r = Math.sqrt(Math.pow(parent_center_pos_x - this.x, 2) + Math.pow(parent_center_pos_y - this.y, 2));
        var dx = d * (parent_center_pos_x - this.x) / r;
        var dy = d * (parent_center_pos_y - this.y) / r;
        this.setVect(dx, dy);
    }

	/**
	 * finalize
	 */
    function finalize(){
        super.finalize();
        invalidate this.layer;
    }
}
