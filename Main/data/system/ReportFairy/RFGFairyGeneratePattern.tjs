/**
 * 妖精生成パターンクラス
 * @author gewalt01
 */
class RFGFairyGeneratePattern {
	var manager; //RFGFairyManager
    var x, y;            //妖精の初期出現位置
    var width, height;    //ウィンドウのサイズ
	var rand;
	var timer;
	var patterns = [];
	var latestPattern;
	
	/**
	 * コンストラクタ
	 * @param	manager RFGFaryManagerオブジェクト
	 */
	function RFGFairyGeneratePattern(manager) {
		this.manager = manager;
        this.rand = new Math.RandomGenerator();
		this.timer = new Timer(this);
		this.timer.enabled = true;
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");
		this.addPatern(1000, "fact");
		this.addPatern(1000, "darm");

		this.readNextPattern();
		this.width = this.manager.parentLayer.width;
		this.height = this.manager.parentLayer.height;
	}

    /**
     * 一定時間ごとに妖精を出現させる
     * @param	ev
     */
    function action(ev) {
		if (this.manager.maxFairy <= this.manager.objects.count) return; //生成上限数の処理
		
		
		this.popPosition();
		var obj = RFGFairyCreator.createFairy(this.manager.window, this.manager.parentLayer, this.manager, this.latestPattern[1]);
		obj.layer.setPos(x, y);//レイヤーの座標だけかえてもFairyオブジェクトの座標は変わらない
		obj.x = this.x;//妖精の座標変更
		obj.y = this.y;//妖精の座標変更
		obj.layer.visible = true;
		obj.setVectForCenter(0.25);//中央方向へ向かうようにする
		obj.enable = 1;
		this.manager.addObject(obj);

		if (this.patterns.count <= 0) { //次に出すものがない
			this.timer.enabled = false;
			return;
		}
		
		this.readNextPattern();
			
		if (this.timer.interval <= 0) this.action(ev);
		
    }

	
    /**
     * 妖精のポップ位置を定める
     */
    function popPosition(){
        var way = rand.random32() % 4;//0:上　1:右　2:下　3:左
        switch(way){
        case 0:
            x=(int)(this.rand.random() * this.manager.parentLayer.width);
            y=0;
            break;
        case 1:
            x=width - 10;
            y=(int)(this.rand.random() * this.manager.parentLayer.height);
            break;
        case 2:
            x=(int)(this.rand.random() * this.manager.parentLayer.width);
            y=height - 10;
            break;
        case 3:
            x=0;
            y=(int)(this.rand.random() * this.manager.parentLayer.height);
            break;
        }
    }
	
	/**
	 * パターン配列からいっこ取り出す
	 */
	function readNextPattern() {
		this.latestPattern = this.patterns.shift();
		if (this.latestPattern === void) {
			this.timer.interval = 0;
			this.timer.enabled = false;
		} else {
			if ((this.timer.interval = this.latestPattern[0]) === 0) this.action();
		}
	}
	
	function addPatern(time, name) {
		this.patterns.add([time, name]);
	}
	
	/**
	 * finalize
	 */
	function finalize() {
		invalidate this.rand;
		invalidate this.timer;
	}
}
