/*
 * 絶対座標を扱えるようにしたレイヤー
 */

class RFGBasicLayer extends Layer{
    var owner;
    
    function RFGBasicLayer(wnd, lay){
        super.Layer(wnd, lay);
    }
    
    function onClick(x, y){
        /* 実際の処理はownerオブジェクトに委譲 */
        try{
            this.owner.onClick(x, y);
        }catch{
            //握りつぶすのはよくないのだけれども…
        }
    }

    /* キー操作はownerオブジェクトに委譲 */
    function onKeyDown(key, shift, process=true){
        try{
            this.owner.onKeyDown(key, shift, process);
        }catch{
            //握りつぶすのはよくないのだけれども…
        }
    }

    /* キー操作はownerオブジェクトに委譲 */
    function onKeyUp(key, shift, process=true){
        try{
            this.owner.onKeyUp(key, shift, process);
        }catch{
            //握りつぶすのはよくないのだけれども…
        }
    }
    
    property boundingLeft
    {
        getter()
        {
            var tmplay  = this;
            var tmpleft = 0;
            while(tmplay != null)
            {
                tmpleft += tmplay.left;
                tmplay = tmplay.parent;
            }

            return tmpleft;
        }
    }

    property boundingTop
    {
        getter()
        {
            var tmplay  = this;
            var tmptop  = 0;
            while(tmplay != null)
            {
                tmptop += tmplay.top;
                tmplay = tmplay.parent;
            }
            
            return tmptop;
        }
    }
}

class ReportFairyGame{
    var mainLayer;
    var reportUnit;
    var fairyUnit;
    var frameUnit;
    
    var report;
    
    var fairyManager; //FairyManager
    var fairies; //array;
    var maxFairyNum;
 
    var crazy = false;
 
    var score;
    
    function ReportFairyGame(wnd, lay){
        this.mainLayer  = RFGLayerCreator.createMainLayer(wnd, lay, this);
        this.report = new RFGReport(wnd, this.mainLayer);
        this.reportUnit = this.report.reportLayer;
        this.fairyUnit = RFGLayerCreator.createFairyUnitLayer(wnd, this.mainLayer);
        this.frameUnit = RFGLayerCreator.createFrameLayer(wnd, this.mainLayer);
        
        this.fairyUnit.bringToFront();
        this.frameUnit.bringToFront();
        
        this.fairyManager = new RFGFairyManeger(wnd, this.fairyUnit);
    }
    

    function togleCrazyMode(){
        if (this.crazy === true) {
            this.frameUnit.visible=false;
            this.report.speed = 2;
            this.crazy = false;
        } else {
            this.frameUnit.visible=true;
            this.report.speed = 20;
            this.crazy = true;
        }
    }

    
    
    /*
     * キー操作はReportFairyが一元管理します
     */
    function onKeyDown(key, shift, process=true){
        switch(key){
        case VK_Z:
            break;
        }
    }

    function onKeyUp(key, shift, process=true){
        switch(key){
        case VK_Z:
            this.togleCrazyMode();
            break;
        case VK_ESCAPE:
            invalidate this;
            break;
        }
    }
    
    function finalize(){
        invalidate this.fairyManager;
        invalidate this.fairyUnit;
        invalidate this.frameUnit;
        invalidate this.mainLayer;
        kag.trigger("fairyend");
    }
}

class RFGFairy{
    var x, y;     //座標
    var vx, vy;   //速度ベクトル
    var enable;   //生死
    var lay;      //FairyLayer
    var timer;    //妖精タイマー
    
    function RFGFairy(wnd,lay){
        //this.lay.parentがNULLになる可能性あり
        this.lay = RFGLayerCreator.createFairyLayer(wnd, lay, this);
        this.setVect(0, 0);
        enable=0;
        this.timer = new Timer(this, "action");//メモリリークの危険性
        this.timer.interval = 1000/60;
        this.timer.enabled = true;
    }
    
    function onClick(x, y){
        this.lay.opacity = 128;
    }
    
    function move(dx, dy){
        this.x += dx;
        this.y += dy;
        this.lay.setPos(this.x, this.y);
        
        //画面からはみ出たら消滅
        if (this.lay.left + this.lay.width < 0 || this.lay.top  + this.lay.height < 0 ||
            this.lay.parent.width  < this.lay.left|| this.lay.parent.height < this.lay.top
        ){
            this.timer.enabled = false;
            this.enable = 0;
        }
    }

    //一定時間ごとに妖精が作動する
    function action(ev){
        if(this.enable) this.move(vx, vy);
    }

    function setVect(vx, vy){
        this.vx = vx;
        this.vy = vy;
    }

    function setVectForCenter(d){
        var parent_center_pos_x = this.lay.parent.width / 2;
        var parent_center_pos_y = this.lay.parent.height / 2;
        var r = Math.sqrt(Math.pow(parent_center_pos_x - this.x, 2) + Math.pow(parent_center_pos_y - this.y, 2));
        var dx = d * (parent_center_pos_x - this.x) / r;
        var dy = d * (parent_center_pos_y - this.y) / r;
        this.setVect(dx, dy);
    }

    function finalize(){
        this.timer.enabled = false;
        invalidate this.timer;
        invalidate this.lay;
    }

}

class RFGFairyManeger{    
    var fairy;
    var x,y;            //妖精の初期出現位置
    var width,height;    //ウィンドウのサイズ
    var maxFairy = 20;
    var rand;
    var way;
    var wnd;
    var lay;//FairyUnitLayer
    
    function RFGFairyManeger(wnd,lay){
        this.lay = lay;
        this.wnd = wnd;
        width=lay.width;
        height=lay.height;
        rand = new Math.RandomGenerator();
        
        this.timer = new Timer(this, "action");//メモリリークの危険性
        this.timer.interval = 1000;
        timer.enabled = true;
        this.fairy=new Array();
        for(var i=0; i<this.maxFairy;i++){
            this.fairy[i]=new RFGFairy(wnd,lay);
        }
    }

    //一定時間ごとに妖精を出現させる
    function action(ev){
        for(var i=0; i<maxFairy; i++){
            if(this.fairy[i].enable==0){
                popPosition();
                invalidate this.fairy[i];
                this.fairy[i]=new RFGFairy(wnd, this.lay);//妖精再作成
                this.fairy[i].lay.setPos(x, y);//レイヤーの座標だけかえてもFairyオブジェクトの座標は変わらない
                this.fairy[i].x = x;//妖精の座標変更
                this.fairy[i].y = y;//妖精の座標変更
                this.fairy[i].lay.visible=true;
                this.fairy[i].setVectForCenter(3);//中央方向へ向かうようにする
                this.fairy[i].enable=1;
                break;
            }
        }
    }
    
    //妖精のポップ位置を定める
    function popPosition(){
        way=rand.random32() % 4;//0:上　1:右　2:下　3:左
        switch(way){
        case 0:
            x=(int)(rand.random()*width);
            y=0;
            break;
        case 1:
            x=width-10;
            y=(int)(rand.random()*height);
            break;
        case 2:
            x=(int)(rand.random()*width);
            y=height-10;
            break;
        case 3:
            x=0;
            y=(int)(rand.random()*height);
            break;
        }
    }
    
    function finalize(){
        for(var i=0; i<this.maxFairy;i++){
            invalidate this.fairy[i];
        }
    }
}


class RFGReport {
    var reportLayer;
    var toRightLayer;
    var toBottomLayer;
    
    var speed = 2;
    
    var timer;
    
    function RFGReport(wnd, lay){
        //RFGReportLayerに変更せよ
        this.reportLayer = RFGLayerCreator.createReportLayer(wnd, lay);
        
        this.defaultPos();
        this.timer = new Timer(this, "action");
        this.timer.interval = 10;
        this.timer.enabled = true;
    }
    
    function CR(){
        this.reportLayer.toRightLayer.left = 0;
    }
    
    function LF(){
        this.reportLayer.toRightLayer.top += 10;
        this.reportLayer.toBottomLayer.top += 10;
    }
    
    function CRLF(){
        this.CR();
        this.LF();
    }
    
    function defaultPos(){
        this.reportLayer.toRightLayer.top = 0;
        this.reportLayer.toRightLayer.left = 0;
        this.reportLayer.toBottomLayer.top = 10;
        this.reportLayer.toBottomLayer.left = 0;
    }
    
    function move(){
        if (this.reportLayer.toRightLayer.width < this.reportLayer.toRightLayer.left) {
            this.CRLF();
            return;
        }
        if (this.reportLayer.toRightLayer.height < this.reportLayer.toRightLayer.top) {
            this.defaultPos();
            return;
        }
        this.reportLayer.toRightLayer.left += this.speed;
    }

    function action(ev){
        this.move();
    }
    
}

class RFGReportLayer extends RFGBasicLayer{
    var toRightLayer;
    var toBottomLayer;

    function RFGReportLayer(wnd, lay){
        super.RFGBasicLayer(wnd, lay);
        
        this.loadImages("image/report.png");
        this.setSizeToImageSize();
        this.visible = true;
        
        this.toRightLayer = new global.RFGBasicLayer(wnd, this);
        this.toRightLayer.width = this.width;
        this.toRightLayer.height = this.height;
        this.toRightLayer.fillRect(0, 0, this.toRightLayer.width, this.toRightLayer.height, 0xFFFF7F7F);
        this.toRightLayer.visible = true;

        this.toBottomLayer = new global.RFGBasicLayer(wnd, this);
        this.toBottomLayer.width = this.width;
        this.toBottomLayer.height = this.height;
        this.toBottomLayer.fillRect(0, 0, this.toBottomLayer.width, this.toBottomLayer.height, 0xFF7FFFFF);
        this.toBottomLayer.visible = true;
    }
}


class RFGLayerCreator{
    function createMainLayer(wnd, lay, owner){
        var m_lay = new RFGBasicLayer(wnd, lay);
        m_lay.owner = owner;
        m_lay.width = lay.width;
        m_lay.height = lay.height;
        m_lay.focusable = true;
        m_lay.fillRect(0, 0, m_lay.width, m_lay.height, 0xFF7F7F7F);
        m_lay.visible=true;
        m_lay.focus();
        
        return m_lay;
    }

    function createFairyUnitLayer(wnd, lay){
        var f_unit_lay;
        f_unit_lay = new RFGBasicLayer(wnd, lay);
        f_unit_lay.width = lay.width;
        f_unit_lay.height = lay.height;
        f_unit_lay.visible = true;

        return f_unit_lay;
    }

    function createFairyLayer(wnd, lay, owner){
        var f_lay = new RFGBasicLayer(wnd, lay);
        f_lay.owner = owner;//メモリリークの危険性
        f_lay.loadImages("image/Fairy.png");
        f_lay.setSizeToImageSize();
        
        return f_lay;
    }

    function createFrameLayer(wnd, lay){
        var f_lay = new RFGBasicLayer(wnd, lay);
        f_lay.width=wnd.innerWidth;
        f_lay.height=wnd.innerHeight;
        f_lay.loadImages("image/frame.png");
        f_lay.setSizeToImageSize();
        f_lay.visible=false;
        
        return f_lay;
    }
    
    function createReportLayer(wnd, lay){
        var r_lay = new RFGReportLayer(wnd, lay);
        r_lay.left = (lay.width  - r_lay.width ) / 2; //両端揃え;
        r_lay.top  = (lay.height - r_lay.height) / 2; //中央揃え;
        
        return r_lay;
    }
}


//var wnd = new Window();
//wnd.width=640;
//wnd.height=480;
//var lay = new Layer(wnd, null);
//lay.width=wnd.innerWidth;
//lay.height=wnd.innerHeight;

//lay.visible=true;
//wnd.visible=true;


//var reportGame = new ReportFairyGame(wnd, lay);
