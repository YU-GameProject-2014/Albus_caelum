/*
 * 絶対座標を扱えるようにしたレイヤー
 */
class ALLayer extends Kayer {
    function ALLayer(wnd, lay){
        super.Layer(wnd, lay);
    }
    
    //property 
}

class ReportFairyGame{
    var mainLayer;
    var reportUnit;
    var fairyUnit;
    var frameUnit;
    
    var fairyManager; //FairyManager
    var fairies; //array;
    var maxFairyNum;
    
    function ReportFairyGame(wnd, lay){
        this.mainLayer  = new RFGLayer(wnd, lay, this);
        //this.reportUnit = new RFGReportLayer(wnd, this.mainLayer);//未実装
        this.fairyUnit  = new Layer(wnd, this.mainLayer);//これもサブクラスにしたほうがよい可能性が
        this.fairyUnit.width = this.mainLayer.width;
        this.fairyUnit.height = this.mainLayer.height;
        this.fairyUnit.visible = true;
        this.frameUnit  = new RFGFrameLayer(wnd, this.mainLayer);
        
        this.fairyUnit.bringToFront();
        this.frameUnit.bringToFront();
        
        this.fairyManager = new RFGFairyManeger(wnd, this.fairyUnit);
    }
    
    //function createLayer(lay){
    //    lay.
    //}
    
    
    /*
     * キー操作はReportFairyが一元管理します
     */
    function onKeyDown(key, shift, process=true){
        this.frameUnit.visible=true;
    }

    function onKeyUp(key, shift, process=true){
        this.frameUnit.visible=false;
    }
    
}

class RFGLayer extends Layer{
    var owner; //ReportFairyオブジェクト

    function RFGLayer(wnd, lay, owner){
        super.Layer(wnd, lay);
        this.owner = owner;
        this.width = lay.width;
        this.height = lay.height;
        this.focusable = true;
        this.fillRect(0, 0, this.width, this.height, 0xFF7F7F7F);
        this.visible=true;
        this.focus();
    }
    
    /* キー操作はReportFairyオブジェクトに委譲 */
    function onKeyDown(key, shift, process=true){
        this.owner.onKeyDown(key, shift, process);
    }

    /* キー操作はReportFairyオブジェクトに委譲 */
    function onKeyUp(key, shift, process=true){
        this.owner.onKeyUp(key, shift, process);
    }
}

class RFGFairy{
    var x, y;     //座標
    var vx, vy;   //速度ベクトル
    var enable;   //生死
    var lay;      //FairyLayer
    var timer;    //妖精タイマー
    
    function RFGFairy(wnd,lay){
        this.lay=new RFGFairyLayer(wnd, lay, this);
        this.setVect(0, 0);
        enable=0;
        this.timer = new Timer(this, "action");//メモリリークの危険性
        this.timer.interval = 1000/60;
        this.timer.enabled = true;
    }
    
    function onClick(x, y){
        this.lay.opacity = 128;
    }

    function onMouseEnter(){
        this.lay.opacity = 128;
    }
    
    function move(dx, dy){
        this.x += dx;
        this.y += dy;
        this.lay.setPos(this.x, this.y);
        
        //画面からはみ出たら消滅
        if (this.lay.left + this.lay.width < 0 || this.lay.top  + this.lay.height < 0 ||
            this.lay.parent.width  < this.lay.left|| this.lay.parent.height < this.lay.top
        ){
            this.enable = 0;
        }
    }

    //一定時間ごとに妖精が作動する
    function action(ev){
        if(this.enable) this.move(vx, vy);
    }

    function setVect(vx, vy){
        this.vx = vx;
        this.vy = vy;
    }

    function setVectForCenter(d){
        var parent_center_pos_x = this.lay.parent.width / 2;
        var parent_center_pos_y = this.lay.parent.height / 2;
        var r = Math.sqrt(Math.pow(parent_center_pos_x - this.x, 2) + Math.pow(parent_center_pos_y - this.y, 2));
        var dx = d * (parent_center_pos_x - this.x) / r;
        var dy = d * (parent_center_pos_y - this.y) / r;
        this.setVect(dx, dy);
    }

}

class RFGFairyLayer extends Layer{
    var fairy; //Fairyオブジェクト本体

    function RFGFairyLayer(wnd, lay, fairy){
        super.Layer(wnd, lay);
        this.fairy = fairy;//メモリリークの危険性
        this.loadImages("image/Fairy.png");
        this.setSizeToImageSize();
        this.hitThreshold=192;
    }

    function onClick(x, y){
        /* 実際の処理はFairyクラスに委譲 */
        this.fairy.onClick(x, y);
    }

    function onMouseEnter(){
        /* 実際の処理はFairyクラスに委譲 */
        this.fairy.onMouseEnter();
    }
}

class RFGFairyManeger{    
    var fairy;
    var x,y;            //妖精の初期出現位置
    var width,height;    //ウィンドウのサイズ
    var maxFairy = 200;
    var rand;
    var way;
    var wnd;
    var lay;//FairyUnitLayer
    
    function RFGFairyManeger(wnd,lay){
        this.lay = lay;
        this.wnd = wnd;
        width=lay.width;
        height=lay.height;
        rand = new Math.RandomGenerator();
        
        this.timer = new Timer(this, "action");//メモリリークの危険性
        this.timer.interval = 10;
        timer.enabled = true;
        fairy=new Array();
        for(var i=0; i<this.maxFairy;i++){
            fairy[i]=new RFGFairy(wnd,lay);
        }
    }

    //一定時間ごとに妖精を出現させる
    function action(ev){
        for(var i=0; i<maxFairy; i++){
            if(fairy[i].enable==0){
                popPosition();
                invalidate fairy[i];
                fairy[i]=new RFGFairy(wnd, this.lay);//妖精再作成
                fairy[i].lay.setPos(x, y);//レイヤーの座標だけかえてもFairyオブジェクトの座標は変わらない
                fairy[i].x = x;//妖精の座標変更
                fairy[i].y = y;//妖精の座標変更
                fairy[i].lay.visible=true;
                fairy[i].setVectForCenter(10);//中央方向へ向かうようにする
                fairy[i].enable=1;
                break;
            }
        }
    }
    
    //妖精のポップ位置を定める
    function popPosition(){
        way=rand.random32() % 4;//0:上　1:右　2:下　3:左
        switch(way){
        case 0:
            x=(int)(rand.random()*width);
            y=0;
            break;
        case 1:
            x=width-10;
            y=(int)(rand.random()*height);
            break;
        case 2:
            x=(int)(rand.random()*width);
            y=height-10;
            break;
        case 3:
            x=0;
            y=(int)(rand.random()*height);
            break;
        }
    }
}


class RFGFrameLayer extends Layer{
    function RFGFrameLayer(wnd, lay){
        super.Layer(wnd, lay);
        this.width=wnd.innerWidth;
        this.height=wnd.innerHeight;
        this.loadImages("image/frame.png");
        this.setSizeToImageSize();
        this.visible=false;
    }
}

//var wnd = new Window();
//wnd.width=640;
//wnd.height=480;
//var lay = new Layer(wnd, null);
//lay.width=wnd.innerWidth;
//lay.height=wnd.innerHeight;

//lay.visible=true;
//wnd.visible=true;


//var reportGame = new ReportFairyGame(wnd, lay);
